import _extends from "@babel/runtime/helpers/esm/extends";
import * as React from 'react';
import { passFilterLogic } from "../filter/gridFilterUtils";
import { useGridApiOptionHandler } from '../../utils/useGridApiEventHandler';
import { useGridApiMethod } from '../../utils/useGridApiMethod';
import* as _gridRowGroupingSelector from "./gridRowGroupingSelector";
import { gridRowGroupingUtils } from "./gridRowGroupingUtils";
import { gridRowTreeSelector } from "../rows/gridRowsSelector";
import { gridColumnLookupSelector } from "../columns/gridColumnsSelector";
import { useGridRegisterPipeProcessor } from "../../core/pipeProcessing/useGridRegisterPipeProcessor";

export const GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD = '__row_group_by_columns_group__';
export const ROW_GROUPING_STRATEGY = 'grouping-columns';

export const getRowGroupingFieldFromGroupingCriteria = groupingCriteria => {
  return groupingCriteria === null ? GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD : `__row_group_by_columns_group_${groupingCriteria}__`;
};

export const getRowGroupingCriteriaFromGroupingField = groupingColDefField => {
  const match = groupingColDefField.match(/^__row_group_by_columns_group_(.*)__$/);
  return match ? match[1] : null;
};

export const isGroupingColumn = field => {
  return field === GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD || getRowGroupingCriteriaFromGroupingField(field) !== null;
};

export const shouldApplyFilterItemOnGroup = (columnField, node) => {
  if (columnField === GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD) {
    return true;
  }
  const groupingCriteriaField = getRowGroupingCriteriaFromGroupingField(columnField);
  return groupingCriteriaField === node.groupingField;
};

export const filterRowTreeFromGroupingColumns = params => {
  const {
    apiRef,
    rowTree,
    isRowMatchingFilters,
    filterModel
  } = params;
  const filteredRowsLookup = {};
  const filteredDescendantCountLookup = {};
  const filterCache = {};
  
  const filterTreeNode = (node, areAncestorsExpanded, ancestorsResults) => {
    const filterResults = {
      passingFilterItems: null,
      passingQuickFilterValues: null
    };
    let isPassingFiltering = false;
    
    if (isRowMatchingFilters && node.type !== 'footer') {
      const shouldApplyItem = node.type === 'group' && node.isAutoGenerated ? columnField => shouldApplyFilterItemOnGroup(columnField, node) : undefined;
      const row = apiRef.current.getRow(node.id);
      isRowMatchingFilters(row, shouldApplyItem, filterResults);
    } else {
      isPassingFiltering = true;
    }
    
    let filteredDescendantCount = 0;
    
    if (node.type === 'group') {
      node.children.forEach(childId => {
        const childNode = rowTree[childId];
        const childSubTreeSize = filterTreeNode(childNode, areAncestorsExpanded && !!node.childrenExpanded, [...ancestorsResults, filterResults]);
        filteredDescendantCount += childSubTreeSize;
      });
    }
    
    if (isPassingFiltering === false) {
      if (node.type === 'group') {
        isPassingFiltering = filteredDescendantCount > 0;
      } else {
        const allResults = [...ancestorsResults, filterResults];
        isPassingFiltering = passFilterLogic(allResults.map(result => result.passingFilterItems), allResults.map(result => result.passingQuickFilterValues), filterModel, params.apiRef, filterCache);
      }
    }
    
    filteredRowsLookup[node.id] = isPassingFiltering;
    
    if (!isPassingFiltering) {
      return 0;
    }
    
    filteredDescendantCountLookup[node.id] = filteredDescendantCount;
    
    if (node.type !== 'group') {
      return filteredDescendantCount + 1;
    }
    
    return filteredDescendantCount;
  };
  
  const nodes = Object.values(rowTree);
  
  for (let i = 0; i < nodes.length; i += 1) {
    const node = nodes[i];
    
    if (node.depth === 0) {
      filterTreeNode(node, true, []);
    }
  }
  
  return {
    filteredRowsLookup,
    filteredDescendantCountLookup
  };
};

export const mergeStateWithRowGroupingModel = rowGroupingModel => state => _extends({}, state, {
  rowGrouping: _extends({}, state.rowGrouping, {
    model: rowGroupingModel
  })
});

export const setStrategyAvailability = (privateApiRef, disableRowGrouping) => {
  let isAvailable;
  
  if (disableRowGrouping) {
    isAvailable = () => false;
  } else {
    isAvailable = () => {
      const rowGroupingSanitizedModel = _gridRowGroupingSelector.gridRowGroupingSanitizedModelSelector(privateApiRef);
      return rowGroupingSanitizedModel.length > 0;
    };
  }
  
  privateApiRef.current.setStrategyAvailability('rowTree', ROW_GROUPING_STRATEGY, isAvailable);
};

export const getCellGroupingCriteria = ({
  row,
  colDef,
  groupingRule,
  apiRef
}) => {
  let key;
  
  if (groupingRule.groupingValueGetter) {
    key = groupingRule.groupingValueGetter(row[groupingRule.field], row, colDef, apiRef);
  } else {
    key = row[groupingRule.field];
  }
  
  return {
    key,
    field: groupingRule.field
  };
};

export const getGroupingRules = ({
  sanitizedRowGroupingModel,
  columnsLookup
}) => sanitizedRowGroupingModel.map(field => ({
  field,
  groupingValueGetter: columnsLookup[field]?.groupingValueGetter
}));

export const areGroupingRulesEqual = (newValue, previousValue) => {
  if (previousValue.length !== newValue.length) {
    return false;
  }
  
  return newValue.every((newRule, newRuleIndex) => {
    const previousRule = previousValue[newRuleIndex];
    
    if (previousRule.groupingValueGetter !== newRule.groupingValueGetter) {
      return false;
    }
    
    if (previousRule.field !== newRule.field) {
      return false;
    }
    
    return true;
  });
};

export const getColDefOverrides = (
  groupingColDefProp,
  fields,
) => {
  if (typeof groupingColDefProp === 'function') {
    return groupingColDefProp({
      groupingName: ROW_GROUPING_STRATEGY,
      fields,
    });
  }

  return groupingColDefProp;
};
